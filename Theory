14-01-2022

Day 1 of 90 Days Coding Challenge

Recursion: -
    When a function calls itself until a certain condition is satisfied is called as recursion.
If there is not a stopping condition then it is called infinite recursion.
Base case: - No more recursion can happen i.e the condition which stops the infinte loop of recursion is called base case
e.g of infinte recursion (Stack overflow): -
      void print()
      {
        cout<<1<<endl;
        print();
      }
      int main()
      {
        print();
        return 0;
       }
       
e.g of correct recursion: -
  cnt = 0;
  f()
  {
    if(cnt == 4)
    {
      return;
    }
    print(cnt);
    cnt++;
    f();
  }
  
  int main()
  {
    f();
  }
  
Basic recursion problem: -

Print name 5 times
#include <iostream>
using namespace std;
void f(int i, int n)
{
	if(i>n)
	{
		return;
	}
	cout<<"Deepa"<<endl;
	f(i+1, n);
}

int main()
{
	int n;
	cin>>n;
	f(1, n);
	return 0;
}                                                           

### Most correct way  ### Time Complexity is O(n)  ### Stack space is O(n)

Print linearly from 1 to N
#include <iostream>
using namespace std;

void print(int i, int n)
{
	if(i>n)
	{
		return;
	}
	cout<<i<<endl;
	print(i+1, n);
}

int main()
{
	int n;
	cin>>n;
	print(1, n);
	return 0;
}

 ### Time Complexity is O(n)  ### Stack space is O(n)

Print linearly from N to 1
#include <iostream>
using namespace std;

void f(int n)
{
	if(n<1)
	{
		return;
	}
	cout<<n<<endl;
	f(n-1);
}

int main()
{
	int n;
	cin>>n;
	f(n);
	return 0;
}

### Time Complexity is O(n)  ### Stack space is O(n)
 
Print 1 to N using back tracking
void print(int i, int n)				// Using Back tracking
{
	if(i<1)
	{
		return;
	}
	print(i-1, n);
	cout<<i<<endl;
}
int main()
{
	int n;
	cin>>n;
	print(n, n);
	return 0;
}

Print N to 1 using back tracking
void f(int i, int n)				// Using Back tracking
{
	if(i>n)
	{
		return;
	}
	f(i+1, n);
	cout<<i<<endl;
}
int main()
{
	int n;
	cin>>n;
	f(1, n);
	return 0;
}

Day 2

Sum of First N numbers using recursion
i) parameterized way
ii) using function

i) Parameterized way: -

void f(int i, int sum)
{
	if(i<1)
	{
		cout<<sum<<endl;
		return;
	}
	f(i-1, sum+i);
}

int main()
{
	int n;
	cin>>n;
	f(n, 0);
	return 0;
}

ii) Functional: -

int f(int n)
{
	if(n<1)
	{
		return 0;
	}
	return n+f(n-1);
}

int main()
{
	int n;
	cin>>n;
	cout<<f(n)<<endl;;
	return 0;
}

Factorial: -
#include <iostream>
using namespace std;

int fact(int n)
{
	if(n == 1)
	{
		return 1;
	}
	return n*fact(n-1);
}
int main()
{
	int n;
	cin>>n;
	cout<<fact(n)<<endl;
	return 0;
}

Reverse an array: -
// Using two pointer
void f(int l, int r, int a[])
{
	if(l>=r)
	{
		return;
	}
	int t = a[r];
	a[r] = a[l];
	a[l] = t;
	f(l+1, r-1, a);
}

int main()
{
	int n;
	cin>>n;
	int a[n];
	for(int i = 0; i<n; i++)
	{
		cin>>a[i];
	}
	f(0, n-1, a);
	for(int i = 0; i<n; i++)
	{
		cout<<a[i]<<" ";
	}
}

// Using two pointer


